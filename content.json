{"pages":[{"title":"關於我","text":"Ring4Six，資訊安全研究員，獨立CTF玩家。對平面設計略有興趣，努力學習中。喜歡與各個領域的專家們互相交流，提升彼此的思維層次。 Logo 上面是我花兩分鐘隨便想出來的logo，因為實在太忙了弄的很隨便。其中黑色的部分是由一個橫躺、短尾的4和較扁平的6所組成，外圍的紅色形成環(ring)的部分。等我有一段長的休假期，再慢慢來重新設計唄！ 部落格起源經歷兩場商業個案競賽，發現自己無法將思想以流暢的文辭表達出來，因此浪費了許多突出的觀點。我開始反省自己是否習慣吃網路速食了呢？曾幾何時我不再提筆了呢？ 因此，希望我能透過這個部落格，學習如何將我的思想輪廓以文字刻畫出來，清晰地傳達給其他人，使意念的傳達更加精確與順暢。","link":"/about/index.html"}],"posts":[{"title":"Linux逆向工程-dlroW olleH","text":"這篇文章用來展示一系列最基本的Linux逆向工程工具，包含: file &lt;executable&gt;：辨別檔案類型 strings &lt;executable&gt;：列出檔案中的字串 ltrace &lt;executable&gt;：執行&lt;executable&gt;，列出所有的library call strace &lt;executable&gt;：執行&lt;executable&gt;，列出所有的system call objdump -d &lt;executable&gt;：將&lt;executable&gt;反組譯， gdb -q &lt;executable&gt;：一步步執行程式進行動態分析 GDB流程控制 b &lt;breakpoint&gt;：&lt;breakpoint&gt;可以是函式名稱（如b main或b *main）、或位址（如b *0x55555555463e） run：開始執行程式 disass：反組譯目前程式執行到的片段（=&gt;所在行會代表下一個執行位置） si：step in，前進，會進到函式裡面 n：next，前進，不進道函式裡面 u *&lt;address&gt;或u &lt;func&gt;：執行直到&lt;address&gt;，執行直到回到&lt;func&gt;，主要用來從callee迅速跳回caller 系統狀態檢測 info registers：列出常用的暫存器值， info all-registers：列出所有暫存器值（包含SSE等） print $&lt;register&gt;：印出&lt;register&gt;中的值，例如:print $rbp x/nfu addr: n：表示輸出連續n個單位(由u決定) f：輸出格式 o - octal x - hexadecimal d - decimal u - unsigned decimal t - binary f - floating point a - address c - char s - string i - instruction u：單位 b - byte h - halfword（16-bit） w - word（32-bit） g - giant word（64-bit）","link":"/2019/05/10/Linux逆向工程-dlroW-olleH/"},{"title":"只需要n/2額外空間的合併排序","text":"最近在閱讀CLRS，堪稱是演算法的聖經讀本。在2.3節，提到了使用分治法設計的$\\Theta(n\\lg n)$排序演算法：合併排序(merge sort)。其概念非常簡單： 若欲排序的序列元素數量大於1，則將序列分成兩半；若否，直接返回不必排序 分別對左邊及右邊的子序列，做合併排序 將排序好的兩子序列做合併，得到排序好的序列 其中最重要的是第3步驟，如何將兩個排序好的子序列合併，產生排序好的序列？依據CLRS第31頁，用Python實作出的合併程式碼如下： 1234567891011121314151617def merge(seq,p,q,r): '''合併兩已排序的子序列seq[p:q]和seq[q:r]''' left = seq[p:q] right = seq[q:r] i,j,k = 0,0,p while i&lt;len(left) and j&lt;len(right): if left[i]&lt;right[j]: seq[k] = left[i] i += 1 else: seq[k] = right[j] j += 1 k += 1 if i&lt;len(left): seq[k:r] = left[i:] else: seq[k:r] = right[j:] 最重要的是第6-13行的程式碼，left[i:]代表左子序列中目前尚未被加入合併序列（seq[p:q]）中的元素；依此類推，right[j:]代表右子序列目前尚未加入合併序列中的元素，seq[k]代表下一個要放入元素的位置： 首先，比較左子序列中剩餘最小的元素（即left[i]）和右子序列中剩餘最小的元素（即right[j]） 若left[i]較小，則將left[i]加入合併序列（seq[k]=left[i]），並將它從左子序列移除（i+=1） 反之則將right[j]加入合併序列（seq[k]=right[j]），並將它從右子序列中移除（j+=1） 增加k 只需要n/2額外空間的合併排序在上面的程式碼中，我們一開始就先將左子序列和右子序列保存起來，避免在合併過程中，更動到他們的值。 我們現在換一個觀點，假設已經放入了$k$個元素，其中$i$個來自left，$j$個來自right，因此$k=i+j$，現在right的剩餘元素個數為$r-q-j$。又 $$k + (r - q - j)\\leq n \\Longleftrightarrow n-k\\geq r - (q+j)$$ 也就是說，總元素扣掉已經加入的元素，會大於等於右子序列剩餘元素（即seq[q+j:r]），所以右子序列尚未加入合併序列的值是不會被更動到的！ 由此得知，右子序列中的所有元素，不會在其被加入合併序列之前改變，我們沒有必要預先保留右子序列的值，可以因此省去right變數： 1234567891011121314def merge(seq,p,q,r): '''合併兩已排序的子序列seq[p:q]和seq[q:r]''' left = seq[p:q] i,j,k = 0,q,p while i&lt;len(left) and j&lt;r: if left[i]&lt;seq[j]: seq[k] = left[i] i += 1 else: seq[k] = seq[j] j += 1 k += 1 if i &lt; len(left): seq[k:r] = left[i:] 注意12、13行，我們不必處理右子序列有剩餘元素的情況；請看下圖，由於中間的部分會等於左子序列剩餘的元素數量，若為0，則右子序列剩餘元素直接接在合併序列右方 合併排序有了merge()，合併排序的實作非常簡單 123456789def merge_sort(seq,beg=0,end=None): if end is None: end = len(seq) if beg &gt;= end-1: #1個或0個元素 return mid = (beg+end)//2 merge_sort(seq,beg,mid) merge_sort(seq,mid,end) merge(seq,beg,mid,end)","link":"/2019/05/06/只需要n-2額外空間的合併排序/"},{"title":"教女友Python資料分析-1.把玩Python","text":"這是《教女友Python資料分析》系列的第一篇文章。顧名思義，這系列文章就是為了教我女友怎麼寫Python而生出來的。但是，因為純教Python對於非本科生的人，顯得有點枯燥乏味，所以我決定以對商管領域最常用到的資料分析作為教學主軸。 這一篇著重在Python最基本的使用上，包括如何做數學運算？以及將計算的結果輸出到螢幕上？主要是用來測試Python是否正確安裝並執行。這裡不會講如何安裝Python，因為我喜歡從頭到腳的客製化以及命令行介面（電影中駭客死盯著得充滿密密麻麻螢光文字的全黑視窗），最多也就一個功能簡單的編輯器。但這理所當然不適合初學者！然而，一旦決定某種安裝方式，我整個系列都要在「我不習慣的環境」演示怎麼寫程式，這樣太痛苦了！所以我決定了，看到這篇文章的人，除我女友外，自己想辦法處理安裝問題，誰叫我只愛我女友呢～。 Hello, World!依照國際慣例，第一支程式要做的事情就是在螢幕上輸出Hello, World!，程式碼如下: 12# hello.pyprint(&apos;Hello, World!&apos;) #在螢幕上顯示「Hello, Wolrd!」 這會產生如下結果: 12ring4six$ python3 hello.py Hello, World! 不用管第一行，只要知道這行執行了我剛才的python程式（寫在hello.py的檔案中） 程式說明接著，我們一行行來看上面的程式怎麼執行。再看一次上面的程式碼： 12# hello.pyprint(&apos;Hello, World!&apos;) #在螢幕上顯示「Hello, Wolrd!」 第1行，# hello.py是不必要的，這行只是告訴妳我把程式寫在hello.py這個檔案裡面。妳以為這是我自己慣用的語法嗎？當然不是！ 在Python中，#字號後面直到換行之前的東西都被稱為註解（comment），註解是用來向其他人說明你的程式如何運行的或是附加一些其他訊息（如：版權資訊）。簡而言之，他是給人看的資訊，不會被電腦處裡。若觀察仔細的話，第2行也有註解！(包含#之後直到程式結束) 第2行，扣掉註解後是print(&#39;Hello, World!&#39;)，print()用來將括弧內的東西輸出到螢幕上，這裡是&#39;Hello, World!&#39;。 也許妳會問，輸出的時候&#39;Hello, Wolrd!&#39;兩邊的單引號怎麼消失了呢？Python中，用引號包住的一系列文字稱為字串，用引號包著的目的是為了區分程式碼和「字串的內容」。 用Python當計算機Python也可以做簡單的算術運算，就跟一般的計算機一樣 1234print(1+1) # 2print((3+2) * 4) # 20print(40/6) # 6.666666666666667print(33.4 * 7.2) #240.48，也可以小數運算 有一些跟一般用法不太一樣的： 12345print(100 % 7) # 100除以7的餘數，應為2print(100 // 7) # 100除以7，只取到整數print(7*(100//7) + 100%7) #a = b*(a//b)+a%bprint(2**3) #2的3次方print(2**0.5) #根號2 此外，也有一些常用的數學運算功能： 123print(abs(-100.4)) #100.4，絕對值print(round(4.5)) #4print(round(5.5)) #6 留意第2,3行的round()，國小到高中教的數學是4捨5入，這裡則是工程上常用的round-to-even，也就是說當尾數是5時，如果進位後可以變成偶數，就進位，否則就捨去，其他情況就跟一般4捨5入的情況一樣。 結論這篇文章主要是給妳看看Python玩起來是什麼模樣，等妳回來～～，我們在實際跑跑看上面的程式。程式的語法多寫就會記起來了，難的是邏輯，不過沒有好的工具怎麼驗證妳的邏輯？","link":"/2019/05/11/教女友Python資料分析-1-把玩Python/"}],"tags":[{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"reverse engineering","slug":"reverse-engineering","link":"/tags/reverse-engineering/"},{"name":"algorithms","slug":"algorithms","link":"/tags/algorithms/"},{"name":"sorting","slug":"sorting","link":"/tags/sorting/"},{"name":"merge sort","slug":"merge-sort","link":"/tags/merge-sort/"},{"name":"divide-and-conquer","slug":"divide-and-conquer","link":"/tags/divide-and-conquer/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"data analysis","slug":"data-analysis","link":"/tags/data-analysis/"}],"categories":[{"name":"教女友Python資料分析","slug":"教女友Python資料分析","link":"/categories/教女友Python資料分析/"}]}