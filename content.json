{"pages":[{"title":"關於我","text":"Ring4Six，資訊安全研究員，獨立CTF玩家。對平面設計略有興趣，努力學習中。喜歡與各個領域的專家們互相交流，提升彼此的思維層次。 Logo 上面是我花兩分鐘隨便想出來的logo，因為實在太忙了弄的很隨便。其中黑色的部分是由一個橫躺、短尾的4和較扁平的6所組成，外圍的紅色形成環(ring)的部分。等我有一段長的休假期，再慢慢來重新設計唄！ 部落格起源經歷兩場商業個案競賽，發現自己無法將思想以流暢的文辭表達出來，因此浪費了許多突出的觀點。我開始反省自己是否習慣吃網路速食了呢？曾幾何時我不再提筆了呢？ 因此，希望我能透過這個部落格，學習如何將我的思想輪廓以文字刻畫出來，清晰地傳達給其他人，使意念的傳達更加精確與順暢。","link":"/about/index.html"}],"posts":[{"title":"只需要n/2額外空間的合併排序","text":"最近在閱讀CLRS，堪稱是演算法的聖經讀本。在2.3節，提到了使用分治法設計的$\\Theta(n\\lg n)$排序演算法：合併排序(merge sort)。其概念非常簡單： 若欲排序的序列元素數量大於1，則將序列分成兩半；若否，直接返回不必排序 分別對左邊及右邊的子序列，做合併排序 將排序好的兩子序列做合併，得到排序好的序列 其中最重要的是第3步驟，如何將兩個排序好的子序列合併，產生排序好的序列？依據CLRS第31頁，用Python實作出的合併程式碼如下： 1234567891011121314151617def merge(seq,p,q,r): '''合併兩已排序的子序列seq[p:q]和seq[q:r]''' left = seq[p:q] right = seq[q:r] i,j,k = 0,0,p while i&lt;len(left) and j&lt;len(right): if left[i]&lt;right[j]: seq[k] = left[i] i += 1 else: seq[k] = right[j] j += 1 k += 1 if i&lt;len(left): seq[k:r] = left[i:] else: seq[k:r] = right[j:] 最重要的是第6-13行的程式碼，left[i:]代表左子序列中目前尚未被加入合併序列（seq[p:q]）中的元素；依此類推，right[j:]代表右子序列目前尚未加入合併序列中的元素，seq[k]代表下一個要放入元素的位置： 首先，比較左子序列中剩餘最小的元素（即left[i]）和右子序列中剩餘最小的元素（即right[j]） 若left[i]較小，則將left[i]加入合併序列（seq[k]=left[i]），並將它從左子序列移除（i+=1） 反之則將right[j]加入合併序列（seq[k]=right[j]），並將它從右子序列中移除（j+=1） 增加k 只需要n/2額外空間的合併排序在上面的程式碼中，我們一開始就先將左子序列和右子序列保存起來，避免在合併過程中，更動到他們的值。 我們現在換一個觀點，假設已經放入了$k$個元素，其中$i$個來自left，$j$個來自right，因此$k=i+j$，現在right的剩餘元素個數為$r-q-j$。又 $$k + (r - q - j)\\leq n \\Longleftrightarrow n-k\\geq r - (q+j)$$ 也就是說，總元素扣掉已經加入的元素，會大於等於右子序列剩餘元素（即seq[q+j:r]），所以右子序列尚未加入合併序列的值是不會被更動到的！ 由此得知，右子序列中的所有元素，不會在其被加入合併序列之前改變，我們沒有必要預先保留右子序列的值，可以因此省去right變數： 1234567891011121314def merge(seq,p,q,r): '''合併兩已排序的子序列seq[p:q]和seq[q:r]''' left = seq[p:q] i,j,k = 0,q,p while i&lt;len(left) and j&lt;r: if left[i]&lt;seq[j]: seq[k] = left[i] i += 1 else: seq[k] = seq[j] j += 1 k += 1 if i &lt; len(left): seq[k:r] = left[i:] 注意12、13行，我們不必處理右子序列有剩餘元素的情況；請看下圖，由於中間的部分會等於左子序列剩餘的元素數量，若為0，則右子序列剩餘元素直接接在合併序列右方 合併排序有了merge()，合併排序的實作非常簡單 123456789def merge_sort(seq,beg=0,end=None): if end is None: end = len(seq) if beg &gt;= end-1: #1個或0個元素 return mid = (beg+end)//2 merge_sort(seq,beg,mid) merge_sort(seq,mid,end) merge(seq,beg,mid,end)","link":"/2019/05/06/只需要n-2額外空間的合併排序/"}],"tags":[{"name":"algorithms","slug":"algorithms","link":"/tags/algorithms/"},{"name":"sorting","slug":"sorting","link":"/tags/sorting/"},{"name":"merge sort","slug":"merge-sort","link":"/tags/merge-sort/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"divide-and-conquer","slug":"divide-and-conquer","link":"/tags/divide-and-conquer/"}],"categories":[]}